Lab 1 FAQ

1 What is the 'op' operator and where is it defined?

The 'op' operator is standard Prolog, as defined in the International
Standards Organisation (ISO) definition of Prolog. For example,

:- op(660,xfy,/). % Nondeterministic choice

includes three arguments: precedence e.g. 600, the type e.g. xfy infix
and the symbol e.g. "/".

Note that the ConGolog program defined in the following publication is
not ISO Prolog:

High-level program execution and the situation calculus Reading:
Giuseppe De Giacomo, Yves Lesprance, and Hector J. Levesque., ConGolog,
a concurrent programming language based on the situation calculus,
Artificial Intelligence, 121(1-2):109--169 (2000)

Ryan Kelly has kindly ported ConGolog to ISO Prolog, used in lab1, that
should run under any ISO Prolog implementation, such as SWI Prolog.

2. Where is e.g. "pi" defined?

pi is defined in congolog.pl as follows:

%%  Nondeterministic choice of arguments may terminate if there is some
%%  choice of arguments for which the program will terminate.
final(pi(V,D),S) :-
    sub(V,_,D,Dr), final(Dr,S).

%%  Nondeterministic choice of arguments may transition if there is an
%%  appropriate binding of the arguments for which the program may
transition.  trans(pi(V,D),S,Dp,Sp) :-
    sub(V,_,D,Dr), trans(Dr,S,Dp,Sp).

Note that the (ground) predicate 'pi' is not defined as a rule by
itself but as an arguments of both the 'final' and 'trans' predicates.

The above form is standard (ISO) Prolog and, not only is this standard
Prolog, but this form is actually encouraged in programming as it helps
to give the Prolog interpreter (and/or compiler) more information  in
relation to where it can expect such predicates to occur - and hence
work to prune more effectively.

3. On what machines in the Department is SWI Prolog also installed?

munyoo

4. Why does concurrent execution in ConGolog seem to occur in blocks of
execution rather than more interleaved?

The semantics of ConGolog only guarantee that a 'legal' execution is
found. No guarantees of what degree of parallelism is achieved is
included - in terms of how interleaved execution is.

In ConGolog, as in Prolog in general, if you press the semi-colon ";"
after one solution is found another (different) legal execution will be
output (try it).

5. How could I get more concurrency, e.g. to always chop tomatoes for
both dishes, omellete and salad, before moving on to subsequent steps
of both these recipies?

- One way would be to re-program to explicitly name the sub-steps (or
subgoals) involved in the recipies and explicitly provide instructions
for the concurrent execution of these subgoals.

- Another way would be to try modifying the semantics of the language
to achieve more interleaved execution. For example modify the
definition of the trans predicate in congolog.pl so that the recursive
call to trans calls the concurrent operations in reverse order, so
change (in congolog.pl) things like

d1 || d2 :- trans(d1,a,e1), e1 || d2.

to something like

d1 || d2 :- trans(d1,a,e1), d2 || e1.

- Yet another way to consider, would be to modify how concurrent
execution is executed to state that two actions must be executed in
parallel it is possible to do so, something like

if poss(a1) and poss(a2) do both actions a1 and a2 concurrently else do
a1 if can't do a2 else do a2 if can't do a1.

6. Why does my ConGolog program seem to hang?

Ryan had a look at Edwins code:

> Edwin had a case where he believes the provided code for ConGolog >
hangs. If I'm correct I think Ben and Andrew you also had a similar
experience?

Ryan Kelly writes:

I've tracked this problem down using Edwin's sample code.  It turns out
that the interpreter doesn't hang, it just takes a *really* long time
to report 'No'.

The reason is that there are many, many legal executions of the program
doPlaceTypeIn(thomas,sugar,bowl1) // doPlaceTypeIn(thomas,egg,bowl1),
because there are many different ways to interleave actions from the
two procedures.  ConGolog explores each of these executions in turn,
but of course they all fail when they are instructed to add an
ingredient that is not available, and it eventually returns 'No' as
expected.

It would be interesting to make a placeNumTypeIn(agt,type,num,dest)
procedure that places a specific number of units of an ingredient in a
bowl, which could fail early if the ingredients were not available.

(This is also a case where IndiGolog's control of the search space
would be useful, if we get time we will cover in lectures)

7.

> When I think about it in this case even if the main procedure is done 
> in parallel it shouldn't take too long to find the first solution 
> because isn't congolog supposed to find the first solution 
> first,which is the same as finding a solution to executing the three procedures sequentially?
> Shouldn't it take roughly the same time as finding a solution to the 
> sequential execution? Yet with my program it took forever.

I noticed a significant speedup with the following new definition:

%%  Nondeterministically select an object of a given type, gain 
control %%  of it, and place it inside a container object.
%%
proc(doPlaceTypeIn(Agt,Type,Dest),
    pi(obj,?and(obj_is_type(obj,Type),not(used(obj,now)))
           : acquire_object(Agt,obj)
           : doPlaceIn(Agt,obj,Dest))
   ).

